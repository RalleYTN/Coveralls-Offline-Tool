/*
 * MIT License
 * 
 * Copyright (c) 2018 Ralph Niemitz
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
package de.ralleytn.software.cofftool;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

import javax.xml.parsers.ParserConfigurationException;

import org.w3c.dom.Document;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;

import de.ralleytn.simple.json.JSONArray;
import de.ralleytn.simple.json.JSONObject;
import de.ralleytn.simple.json.JSONParseException;

/**
 * Just a small command line tool to submit coverage data that was collected by Eclipse to Coveralls.
 * A {@code report.xml} and a {@code report.dtd} file should be in the same directory as this program.
 * @author Ralph Niemitz/RalleYTN(ralph.niemitz@gmx.de)
 * @version 1.2.0
 * @since 1.0.0
 */
public final class Program {

	private static final File REPORT_XML = new File("report.xml");
	private static final File REPORT_JSON = new File("coveralls.json");
	
	private Program() {}
	
	/**
	 * Entry point for the program.
	 * @param args	the arguments:
	 * 				<p><table border=1>
	 * 					<tr>
	 * 						<th>Index</th>
	 * 						<th>Parameter</th>
	 * 					</tr>
	 * 					<tr>
	 * 						<td>0</td>
	 * 						<td>location of the source code on default package level</td>
	 * 					</tr>
	 * 					<tr>
	 * 						<td>1</td>
	 * 						<td>your Travis CI access token (generated by the client)</td>
	 * 					</tr>
	 * 	 				<tr>
	 * 						<td>2</td>
	 * 						<td>the repository: <code>{GitHub Name}/{GitHub Repo}</code></td>
	 * 					</tr>
	 * 				</table></p>
	 * @since 1.0.0
	 */
	public static void main(String[] args) {

		try {

			if(args.length == 3) {
				
				long serviceJobId = new TravisClient(args[1]).getLatestServiceJobId(args[2]);
				JSONArray coverageReportData = Program.createCoverageReportData(args[0]);
				JSONObject object = Program.createCoverageReportObject(serviceJobId, coverageReportData);
				Program.writeCoverageReportFile(object);
				Program.askToSendCoverageReport();
				
			} else {
				
				System.err.println("Invalid number of arguments!");
			}

		} catch(IOException | SAXException | ParserConfigurationException | JSONParseException exception) {
			
			Util.printException(exception);
		}
	}
	
	/**
	 * Creates the JSON object that will be sent to Coveralls.
	 * @param serviceJobId the service job id
	 * @param coverageReportData the coverage report data array
	 * @return the JSON object
	 * @since 1.2.0
	 */
	private static final JSONObject createCoverageReportObject(long serviceJobId, JSONArray coverageReportData) {
		
		JSONObject object = new JSONObject();
		object.put("service_job_id", serviceJobId);
		object.put("service_name", "travis-ci");
		object.put("source_files", coverageReportData);
		
		return object;
	}
	
	/**
	 * Writes the JSON object that should be send to Coveralls in a file.
	 * @param coverageReport the coverage report object
	 * @throws IOException if something went wrong while writing
	 * @since 1.2.0
	 */
	private static final void writeCoverageReportFile(JSONObject coverageReport) throws IOException {
		
		System.out.println("[INFO] Create " + Program.REPORT_JSON.getName());
		
		try(BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(Program.REPORT_JSON)))) {
			
			coverageReport.write(writer);
		}
	}
	
	/**
	 * Asks the user to type in 'submit' before sending the report to Coveralls
	 * @throws IOException if something went wrong while sending the report
	 * @since 1.2.0
	 */
	private static final void askToSendCoverageReport() throws IOException {
		
		System.out.println();
		System.out.print("Do you want to submit the coverage report? If yes, type 'submit': ");
		
		@SuppressWarnings("resource")
		String confirmation = new Scanner(System.in).nextLine();
		
		if("submit".equalsIgnoreCase(confirmation)) {
			
			boolean success = new CoverallsClient().submitCoverageReport(Program.REPORT_JSON);
			
			if(success) {
				
				System.out.println("[INFO] Sucessfully submitted the coverage report to Coveralls.");
				
			} else {
				
				System.err.println("[ERROR] Failed to submit the coverage report to Coveralls!");
			}
		
		} else {
			
			System.out.println("Process will be aborted.");
		}
	}
	
	/**
	 * Creates the {@linkplain JSONArray} with the coverage data that will be send to Coveralls based on the {@code report.xml} file that should be in
	 * the same directory as this program.
	 * @param sourceLocation the location of the source files on default package level
	 * @return the created {@linkplain JSONArray}
	 * @throws SAXException if the XML of the {@code report.xml} file is invalid
	 * @throws IOException if some files could not be read
	 * @throws ParserConfigurationException if the XML of the {@code report.xml} file is invalid
	 * @since 1.0.0
	 */
	private static final JSONArray createCoverageReportData(String sourceLocation) throws SAXException, IOException, ParserConfigurationException {
		
		JSONArray sourceFiles = new JSONArray();
		List<File> relevantSourceFiles = Program.collectSourceFiles(new File(sourceLocation));
		Document document = Util.parseXML(Program.REPORT_XML);
		NodeList nodes = document.getElementsByTagName("sourcefile");
		
		System.out.println("[INFO] Create coverage report...");
		System.out.println("[INFO]");
		System.out.println("[INFO] ----");
		
		int sumLines = 0;
		int sumCoverred = 0;
		int sumMissed = 0;
		
		for(File sourceFile : relevantSourceFiles) {
			
			Node node = Util.getNodeForSourceFile(nodes, sourceLocation, sourceFile);
			int lines = Util.getLineCount(sourceFile);
			sumLines += lines;
			Integer[] coverage = new Integer[lines];
			String fullName = Util.getFullName(sourceLocation, sourceFile);
			int coverred = 0;
			int missed = 0;
			
			if(node != null) {
				
				NodeList childs = node.getChildNodes();
				
				for(int index = 0; index < childs.getLength(); index++) {
					
					Node child = childs.item(index);
					
					if(child.getNodeName().equals("line")) {

						NamedNodeMap attributes = child.getAttributes();
						int line = Integer.parseInt(attributes.getNamedItem("nr").getNodeValue());
						int covered = Integer.parseInt(attributes.getNamedItem("ci").getNodeValue());
						
						if(covered > 0) {
							
							coverred++;
							
						} else {
							
							missed++;
						}
						
						coverage[line - 1] = covered;
					}
				}
				
				sumCoverred += coverred;
				sumMissed += missed;
			}

			System.out.println("[INFO] " + fullName + " - Total: " + lines + ", Relevant: " + (coverred + missed) + ", Covered: " + coverred + ", Missed: " + missed);
			sourceFiles.add(Program.createCoverageReportDataElement(coverage, sourceLocation, sourceFile));
		}
		
		System.out.println("[INFO] All Files - Total: " + sumLines + ", Relevant: " + (sumCoverred + sumMissed) + ", Covered: " + sumCoverred + ", Missed: " + sumMissed);
		System.out.println("[INFO] ----");
		System.out.println("[INFO]");
		
		return sourceFiles;
	}
	
	/**
	 * Creates an element in the coverage report data array.
	 * @param coverage the coverage data
	 * @param sourceFile the source file
	 * @return a JSON object that should be part of the coverage report data array
	 * @throws IOException if something went wrong while reading the source file for the MD5 hash
	 * @since 1.2.0
	 */
	private static final JSONObject createCoverageReportDataElement(Integer[] coverage, String sourceLocation, File sourceFile) throws IOException {
		
		JSONObject object = new JSONObject();
		object.put("source_digest", Util.createMD5(Util.readFile(sourceFile)));
		object.put("name", "src/main/java/" + Util.getFullName(sourceLocation, sourceFile));
		object.put("coverage", new JSONArray(coverage));
		
		return object;
	}
	
	/**
	 * Searches for all source files. (except the module-info.java)
	 * @param sourceFolder the location of the source files on default package level
	 * @return a list with the relevant source files
	 * @since 1.0.0
	 */
	private static final List<File> collectSourceFiles(File sourceFolder) {
		
		System.out.println("[INFO] Collect project source files...");
		System.out.println("[INFO]");
		System.out.println("[INFO] ----");
		
		List<File> sourceFiles = new ArrayList<>();
		Util.crawlThroughFileTree(sourceFolder, file -> {
			
			if(file.isFile() && file.getName().toLowerCase().endsWith(".java") && !file.getName().equals("module-info.java")) {
				
				System.out.println("[INFO] Collect " + file.getAbsolutePath());
				sourceFiles.add(file);
			}
		});
		
		System.out.println("[INFO] ----");
		System.out.println("[INFO]");
		
		return sourceFiles;
	}
}
